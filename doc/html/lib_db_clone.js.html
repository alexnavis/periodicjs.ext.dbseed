<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/db_clone.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/db_clone.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
const path = require('path');
const Promisie = require('promisie');
const fs = Promisie.promisifyAll(require('fs-extra'));
const async = require('async');
const capitalize = require('capitalize');
const moment = require('moment');
const mongo = require('mongoose');
const Transform = require('stream').Transform;

var logger;
var mongoose;
var appSettings;
var CoreController;
var CoreUtilities;
var appenvironment;
var transformConfiguration;
var exportDB;
var exportOptions;

/**
 * Appends json data to json file either being pushing object into data array or merging objects if data property does not exist.  Will also create new file if file does not exist
 * @param  {string} filePath  Path to json file 
 * @param  {Object} writeData JSON data to be appended to file
 * @return {Object} Function returns an Promise
 */
var appendJSONToFile = function (filePath, writeData) {
	return fs.statAsync(filePath)
		.then(() => fs.readJsonAsync(filePath), () => true)
		.then(fileData => {
			if (typeof fileData === 'boolean' &amp;&amp; fileData) { return fs.writeJsonAsync(filePath, writeData); }
			else {
				if (fileData.data &amp;&amp; Array.isArray(fileData.data)) { fileData.data.push(writeData); }
				else { fileData = Object.assign(fileData, fileData.data); }
				return fs.writeJsonAsync(filePath, fileData);
			}
		})
		.catch(e => Promise.reject(e));
};

/**
 * Utility method for writing json data to a file.  Can optionally write data to write stream, append json data to a file or create/overwrite a json file
 * @param  {Object} options Options object for function
 * @param {Object} options.writeStream fs writeable stream object.  Defaults to writing json data to stream if this option is passed
 * @param {string|Object} options.writeData JSON data to be written to file.  Must be stringified if writeStream option is passed
 * @param {string} options.filePath Path to json file
 * @param {Boolean} options.overwrite Optional flag which determines if file will be overwritten with json data or if data should be appended to file
 * @param  {Function} cb      Optional callback
 * @return {Object}  If no cb argument is not passed returns a Promise
 */
var writeToFile = function (options, cb) {
	if (options.writeStream) {
		options.writeStream.write(`${ options.writeData }${ (!options.isLast) ? ',\r\n' : '\r\n]\r\n}' }`);
		return options.writeStream;
	}
	else {
		let fn = function (callback) {
			if (!options.overwrite) {
				appendJSONToFile(options.filePath, options.writeData)
					.then(() => {
						callback(null, 'File write complete');
					}, callback);
			}
			else {
				fs.writeJson(options.filePath, options.writeData, err => {
					if (err) { callback(err);	}
					else { callback(null, 'File write complete'); }
				});
			}
		};
		if (typeof cb === 'function') { fn(cb); }
		else { return Promisie.promisify(fn)(); }
	}
};

/**
 * Pulls db seed settings out of file.  Will ensure file exists and either requires or reads json data depending on file type
 * @param  {string}   filePath Optional path to settings file.  Will default to periodic app controller_settings.js file if none is specified
 * @param  {Function} cb       Options callback function
 * @return {Object}            Returns a Promise if no callback function is passed
 */
var getModelSettingsFromFile = function (filePath, cb) {
	filePath = (typeof filePath === 'string') ? filePath : path.join(__dirname, '../../../app/controller/controller_settings.js');
	let fn = function (callback) {
		fs.statAsync(filePath)
			.then(() => {
				if (path.extname(filePath) === '.js') {
					let settings = require(filePath);
					callback(null, settings);
				}
				else {
					fs.readJsonAsync(filePath)
						.then(settings => {
							callback(null, settings);
						}, callback);
				}
			}, callback);
	};
	if (typeof cb === 'function') { fn(cb); }
	else { return Promisie.promisify(fn)(); }
};

/**
 * Infers db seed settings from the models that exist for a given mongoose instance
 * @param  {Object} mongooseConnection Mongoose connection object
 * @return {Object} Returns a settings object that contains model_name and load_model_population properties
 */
var getModelSettings = function (mongooseConnection) {
	try {
		let pullModelDetails = function (model) {
			let populationSettings = [];
			let paths = model.schema.paths;
			for (let key in paths) {
				if (paths[key].instance === 'ObjectID') {
					populationSettings.push(paths[key].path);
				}
			}
			return {
				model_name: model.modelName.toLowerCase(),
				load_model_population: populationSettings.join(' ')
			};
		};
		let settings = Object.keys(mongooseConnection.models).reduce((config, key) => {
			let model = mongooseConnection.models[key];
			if (model) { config[key.toLowerCase()] = pullModelDetails(model); }
			return config;
		}, {});
		return settings;
	}
	catch (e) {
		logger.warn('Could not generate seetings from model', e);
	}
};

/**
 * Gets a combined population string from a settings object load_model_population and load_multiple_model_population properties
 * @param  {Object} options Population settings from the controller_settings object for a given schema
 * @return {string}         A population string with only unique values
 */
var getPopulationSettings = function (options) {
	if (!options.load_model_population &amp;&amp; options.load_multiple_model_population) { return options.load_multiple_model_population; }
	else if (options.load_model_population &amp;&amp; !options.load_multiple_model_population) { return options.load_model_population; }
	else if (!options.load_model_population &amp;&amp; !options.load_multiple_model_population) { return ''; }
	else {
		let population = options.load_model_population.split(' ');
		options.load_multiple_model_population.split(' ').forEach(str => {
			if (population.indexOf(str) === -1) { population.push(str); }
		});
		return population.join(' ');
	}
};

/**
 * Given a settings object function creates a populated mongoose query stream for a model
 * @param  {Object} settings Settings object created by getModelSettings or getModelSettingsFromFile
 * @param {string} settings.model_name Name of the mongoose model
 * @return {Object}          Mongoose query stream
 */
var getMongoQueryStream = function (options) {
	let model_name;
	if (options.custom_model_names &amp;&amp; typeof options.custom_model_names[options.model_settings.model_name] === 'string') { model_name = options.custom_model_names[options.model_settings.model_name]; }
	else if (options.capitalize_suffix &amp;&amp; options.capitalize_suffix.length) { model_name = options.model_settings.model_name.replace(new RegExp(`${options.capitalize_suffix}$`), capitalize(options.capitalize_suffix)); }
	else { model_name = options.model_settings.model_name; }
	let Model = options.connection.model(capitalize(model_name));
	let populationSettings = getPopulationSettings(options.model_settings);
	return Promisie.promisify(Model.count, Model)({})
		.then(count => {
			let dataStream = Model.find({}).populate(populationSettings).cursor();
			return { stream: dataStream, count };
		}, e => Promise.reject(e));
};

/**
 * Utility function for wrapping output json in an object with a "data" property
 * @param {Object} options Options for the seed file creation finalize function
 * @param {Object|Number} options.records Total count of inserted records or an object containing total records indexed by datatype
 * @param {Boolean} options.usePartition Boolean flag describing if seperate files were created for each of the different data types
 * @param {string} options.writePath Absolute path for the JSON seed file
 * @return {Function} Returns a function used for finalizing the seed file by wrapping it in a object and setting it to the data property of that object
 */
var setupCompleteSeedFile = function (options, cb) {
	let { records, usePartition, writePath } = options;
	/**
	 * Completes creation of seed file by reading file and wrapping data in an object under the "data" property
	 * @param {string} wp Path to the un-finalized seed file
	 * @param {Function} callback Callback function
	 */
	let completeFile = function (wp) {
		return Promisie.resolve({
			records: (!usePartition) ? records : records[Object.keys(records).filter(key => new RegExp(key, 'gi').test(path.basename(wp)))[0]],
			path: wp
		});
	};
	return function () {
		if (usePartition) {
			fs.readdirAsync(path.dirname(writePath))
				.then(paths => {
					paths = paths.filter(filePath => {
						let regexp = new RegExp(`^${ path.basename(writePath, '.json') }.+\\.json$`);
						return regexp.test(filePath);
					});
					return Promisie.map(paths, 1, filePath => {
						return completeFile(path.join(path.dirname(writePath), filePath));
					});
				})
				.then(cb.bind(null, null))
				.catch(cb);
		}
		else { completeFile(writePath || './seed_data.json', cb); }
	};
};

/**
 * Initializes a transform stream that is used to prepend data to a seed file and then push documents to file
 * @return {Object} instance of Transform Stream
 */
var createDataTransformStream = function () {
	let isFirst = true;
	let transform = new Transform();
	transform._transform = function (data, enc, transformcb) {
		if (isFirst) {
			isFirst = false;
			this.push('{\r\n"data": [\r\n' + data.toString());
		}
		else { this.push(data.toString()); }
		transformcb();
	};
	return transform;
};

/**
 * Switches between writeStreams dependent on the specified write path
 * @param  {Object} data json data to be written to file
 * @param {string} data.datatype Data must contain datatype property which is used to determine write path
 * @return {Object}      Returns a fs writeable stream
 */
var WriteStreamSwitchboard = class WriteStreamSwitchboard {
	/**
	 * Constructor for WriteStreamSwitchboard class
	 * @param  {Object} options Configurable options for the stream switchboard
	 * @param {string} options.writePath The dirname that the seed files should be written to
	 * @param {number} options.batchSize If batchsize is set to a non-zero number seed files will be truncated at batchsize with multiple files being created for a given collection if necessary
	 * @return {Object}         "this"
	 */
	constructor (options) {
		let streamHolder = {
			_current: {
				path: null,
				fd: null
			}
		};
		this.writePath = options.writePath;
		this.batchSize = options.batchSize;
		this.getStreamHolder = () => streamHolder;
		this.removeStream = (datatype) => {
			streamHolder[datatype] = {};
			return streamHolder;
		};
		return this;
	}
	/**
	 * Retrieves a write stream from the private var streamHolder or creates a write stream if there is no applicable stream. A new stream is created when either a new collection begins exporting or once a batch size limit is reached and a new file must be created
	 * @param  {Object} data    Collection data used to retrieve or create a write stream from streamHolder
	 * @param {string} data.datatype The name of the collection being exported
	 * @param  {number} [batches] If batchsize limit is specified the current batch number used in creating a new write stream
	 * @return {Object}         The write stream that will be used in writing export data
	 */
	getStream (data, batches) {
		let streamHolder = this.getStreamHolder();
		if (streamHolder._current.path !== this.writePath.replace(/(.+)(\.json)/, `$1_${data.datatype}${ (typeof this.batchSize === 'number') ? '('+ (batches[data.datatype] || 0) +')' : '' }$2`)) {
			if (!streamHolder[data.datatype] || !streamHolder[data.datatype].fd) {
				let wp = this.writePath.replace(/(.+)(\.json)/, `$1_${data.datatype}${ (typeof this.batchSize === 'number') ? '('+ (batches[data.datatype] || 0) +')' : '' }$2`);
				let fd = fs.createWriteStream(wp);
				let transformer = createDataTransformStream();
				transformer.pipe(fd);
				streamHolder[data.datatype] = { path: wp, fd: transformer };
			}
			streamHolder._current = streamHolder[data.datatype];
		}
		return streamHolder._current.fd;
	}
};

/**
 * Creates a function which tracks the number of documents that have been written to file, the current batch number and the expected number of batches. Process determines the end of file from this data and also returns this data as part once it resolves
 * @param  {Boolean} usePartition If true batch size limit will be respected and files will be truncated at that limit
 * @param  {number} batchSize    The max number of documents that should be in a file
 * @return {Function}              Returns a function that handles tracking the total number of documents, batch size limits etc.
 */
var handleEndOfFile = function (usePartition, batchSize) {
	let records = (!usePartition) ? 0 : {};
	let batch_records = (!usePartition) ? 0 : {};
	let batches = (!usePartition) ? 0 : {};
	let expected_batches = (!usePartition) ? null : {};
	return function (d) {
		if (!usePartition) {
			records++;
			batch_records++;
		}
		else {
			records[d.data.datatype] = (typeof records[d.data.datatype] === 'number') ? records[d.data.datatype] : 0;
			records[d.data.datatype]++;
			batch_records[d.data.datatype] = (typeof batch_records[d.data.datatype] === 'number') ? batch_records[d.data.datatype] : 0;
			batch_records[d.data.datatype]++;
		}
		let isLast;
		if (typeof writeStream === 'function' &amp;&amp; typeof batchSize !== 'number') { isLast = (records[d.data.datatype] >= d.count); }
		else if (typeof batchSize === 'number') {
			if (!usePartition &amp;&amp; typeof expected_batches !== 'number') { expected_batches = d.count / batchSize; }
			else if (typeof expected_batches[d.data.datatype] !== 'number') { expected_batches[d.data.datatype] = d.count / batchSize; }
			if (((typeof batch_records === 'number' &amp;&amp; batch_records >= batchSize) || (batch_records[d.data.datatype] >= batchSize)) || ((typeof records === 'number' &amp;&amp; records === d.count) || (records[d.data.datatype] === d.count))) {
				isLast = true;
				if (!usePartition) {
					batch_records = 0;
					batches++;
					if ((batches + 1) > expected_batches) {
						let decimal = Number(expected_batches.toString().replace(/^\d*(\.\d+)$/, '0$1'));
						batchSize = batchSize * decimal;
					}
				}
				else {
					batch_records[d.data.datatype] = 0;
					batches[d.data.datatype] = (typeof batches[d.data.datatype] === 'number') ? batches[d.data.datatype] : 0;
					batches[d.data.datatype]++;
					if ((batches[d.data.datatype] + 1) > expected_batches) {
						let decimal = Number(expected_batches.toString().replace(/^\d*(\.\d+)$/, '0$1'));
						batchSize = batchSize * decimal;
					}
				}
			}
			else { isLast = false; }
		}
		else { isLast = (records >= d.count); }
		return { isLast, records, batches, batch_size: batchSize };
	};
};

/**
 * Configures a queue whose worker writes json data to a writeable stream
 * @param  {string} writePath    Optional file path for the data write will default to ./seed_data.json if argument is undefined
 * @param  {Boolean} usePartition If true seperate json files will be created for each collection.  Files names will match writePath with appended collection name
 * @param  {Function} onDrain      Function to be called once last task is returned from worker
 * @return {Object}              Returns async queue object
 */
var configureWriteQueue = function (writePath, usePartition, batchSize, onDrain) {
	writePath = (typeof writePath === 'string' &amp;&amp; writePath.length) ? writePath : path.join(__dirname, '../../../content/files/dbseed/seed_data.json');
	let records = (!usePartition) ? 0 : {};
	let eofHandler = handleEndOfFile(usePartition, batchSize);
	let writeStreamSwitchboard = new WriteStreamSwitchboard({ batchSize, writePath });
	let writeStream = (usePartition === true) ? writeStreamSwitchboard.getStream.bind(writeStreamSwitchboard) : createDataTransformStream();
	if (typeof writeStream !== 'function') { writeStream.pipe(fs.createWriteStream(writePath)); }
	let queue = async.queue(function (d, cb) {
		process.nextTick(() => {
			let eofData = eofHandler(d);
			let { batches, isLast, batch_size } = eofData;
			batchSize = (batchSize !== batch_size) ? batch_size : batchSize;
			if (!usePartition) { records++; }
			else {
				records[d.data.datatype] = (typeof records[d.data.datatype] === 'number') ? records[d.data.datatype] : 0;
				records[d.data.datatype]++;
			}
			writeToFile({
				writeStream: (typeof writeStream === 'function') ? writeStream(d.data, batches) : writeStream,
				writeData: JSON.stringify(d.data),
				isLast
			});
			if (isLast &amp;&amp; typeof batchSize === 'number') {
				process.nextTick(() => {
					if (usePartition) { writeStreamSwitchboard.removeStream(d.data.datatype); }
					else {
						let fd = fs.createWriteStream(writePath.replace(/(.+)(\.json)/, `$1(${batches})$2`));
						writeStream = createDataTransformStream();
						writeStream.pipe(fd);
					}
					cb();
				});
			} 
			else { cb(); }
		});
	}, 1);
	let timeout;
	let done = setupCompleteSeedFile({ records, usePartition, writePath }, onDrain);
	queue.drain = function () {
		if (!timeout) { timeout = setTimeout(done, 5000); }
		else {
			clearTimeout(timeout);
			timeout = setTimeout(done, 5000);
		}
	};
	return queue;
};

/**
 * Runs transform function on data or auto resolves data if there is an error or if operation argument is not a function
 * @param  {Object} data      Document from mongoose collection
 * @param  {Function} operation Transform function to be run on the given data object
 * @return {Object}          Returns a Promise
 */
var transformDataForSeed = function (data, operation) {
	if (typeof operation !== 'function') { return Promise.resolve(data); }
	try {
		return Promise.resolve(operation(data));
	}
	catch (e) {
		logger.warn('Transform function could not be completed', e);
		return Promise.resolve(data);
	}
};

/**
 * Configures mongo query streams for all models on a mongoose instance to push data into queue on "data"
 * @param {Object} options Options for configuring functionality of query streams
 * @param {Object} options.model_settings Object containing schema data for all schemas on mongoose instance indexed by document type
 * @param {Object} [options.transform_configuration] A set of transform functions indexed by document type
 * @param {Boolean|string} [options.skipUserSeeds] If any non-falsy value is passed model wont be included in seed this option can be set for different models following the same pattern "skip" + "model name" + "seeds"
 * @param {Object} queue Async queue or any queue that has a push method which accepts a data and cb argument
 * @return {Object} Mongo query streams indexed by document type
 */
var configureQueryStreams = function (options) {
	let { model_settings, transform_configuration, queue } = options;
	try {
		let skipOptionRegexp = /^(skip)(\w+)(seeds)$/i;
		let skip_models = Object.keys(options).reduce((result, key) => {
			if (skipOptionRegexp.test(key) &amp;&amp; options[key]) { result.push(key.replace(skipOptionRegexp, '$2').toLowerCase()); }
			return result;
		}, []);
		return Promisie.parallel(Object.keys(model_settings).reduce((results, key) => {
			if (skip_models.indexOf(key) === -1) {
				let mongoOptions = Object.assign({ connection: options.mongooseConnection || mongoose }, options, { model_settings: model_settings[key] });
				results[key] = () => getMongoQueryStream(mongoOptions);
			}
			return results;
		}, {}))
			.then(results => {
				let totalItems = Object.keys(results).reduce((total, datatype) => {
					total += results[datatype].count;
					return total;
				}, 0);
				return Object.keys(results).reduce((streams, datatype) => {
					streams[datatype] = results[datatype].stream;
					streams[datatype].on('data', data => {
						data = (typeof data.toObject === 'function') ? data.toObject() : data;
						transformDataForSeed(data, (transform_configuration) ? transform_configuration[datatype] : null)
							.then(transformed => {
								let writeData = { datatype, datadocument: transformed };
								queue.push({ data: writeData, count: (options.partition) ? results[datatype].count : totalItems }, err => {
									if (err) { logger.warn('Could not write data to seed', err.stack); }
									else { logger.silly('Successfully wrote data to seed', writeData); }
								});
							}, logger.warn.bind(logger));
					});
					return streams;
				}, {});
			})
			.then(results => results)
			.catch(e => Promise.reject(e));
	}
	catch (e) {
		return Promise.reject(e);
	}
};

/**
 * Ensures that correct mongo db instance is used and has properly connected
 * @param {Object} [mongooseConnection] A connected mongoose instance if this argument is passed it will be assumed that this connection should be used
 * @return {Object} Connected mongoose instance
 */
var ensureDBConnection = function (mongooseConnection) {
	return new Promisie((resolve, reject) => {
		try {
			let db;
			let waitForConnection = false;
			if (mongooseConnection) {
				if (typeof mongooseConnection.url === 'string' &amp;&amp; mongooseConnection.mongooptions &amp;&amp; typeof mongooseConnection.mongooptions === 'object') {
					db = mongo.connect(mongooseConnection.url, mongooseConnection.mongooptions);
					waitForConnection = true;
				}
				else { db = mongooseConnection; }
			}
			else if (exportDB) {
				if (typeof exportDB.url === 'string' &amp;&amp; exportDB.mongooptions &amp;&amp; typeof exportDB.mongooptions === 'object') {
					db = mongo.connect(exportDB.url, exportDB.mongooptions);
					waitForConnection = true;
				}
				else { db = exportDB; }
			}
			else { db = mongoose; }
			if (waitForConnection) {
				db.connection.once('connected', () => resolve(db));
				db.connection.once('error', reject);
			}
			else { resolve(db); }
		}
		catch (e) {
			reject(e);
		}
	});
};

/**
 * Ensures the directory seed file is being written to exists
 * @param  {string} outputPath The path to either the parent directory or the full file path
 * @return {Object}            Promise that resolves once directory has been ensured
 */
var ensureExportDirectory = function (outputPath) {
	if (typeof outputPath === 'string') {
		if (path.extname(outputPath) === '') { return fs.ensureDirAsync(outputPath); }
		else {
			let dirname = path.dirname(outputPath);
			return fs.ensureDirAsync(dirname);
		}
	}
	else { return Promisie.resolve(); }
};

/**
 * Runs full create seed suite
 * @param  {Object}   options Options object for create seed function
 * @param {Boolean} options.useConfigurationFile Default behavior is to infer settings from the mongoose instance set this property to true in order to pull settings from config file
 * @param {string} options.configPath If using configuration file this sets the path to that file
 * @param {Object} options.mongooseConnection Mongoose instance to be used in seed defaults to the current periodic instance
 * @param {string} options.outputPath Path for seed json file
 * @param {Boolean} options.partition Will create separate json seed file per collection if true
 * @param  {Function} cb      Optional callback function
 * @return {Object}           Returns a Promise if callback is not passed
 */
var createSeed = function (options, cb) {
	options = Object.assign({}, exportOptions, options);
	options.outputPath = (typeof options.outputPath === 'string' &amp;&amp; options.outputPath.length) ? options.outputPath : path.join(__dirname, `../../../content/files/dbseed/${ moment().format('YYYY-MM-DD-hh:mm:ss') }/seed_data.json`);
	let fn = function (callback) {
		let transform_configuration = Object.assign({}, transformConfiguration);
		ensureExportDirectory(options.outputPath)
			.then(ensureDBConnection.bind(null, options.mongooseConnection))
			.then(dbConnection => {
				options.mongooseConnection = dbConnection;
				return new Promise((resolve, reject) => {
					if (options.useConfigurationFile) {
						getModelSettingsFromFile(options.configPath)
							.then(resolve, reject);
					}
					else if (options.mongooseConnection) { resolve(getModelSettings(options.mongooseConnection)); }
				});
			})	
			.then(model_settings => {
				let queue = configureWriteQueue(options.outputPath, options.partition, options.batch, callback);
				return configureQueryStreams(Object.assign({}, options, { model_settings, transform_configuration, queue }));
			})
			.then(streams => {
				Object.keys(streams).forEach(key => {
					if (streams.hasOwnProperty(key)) {
						streams[key].on('end', () => {
							logger.info(`${ key } data stream has ended`);
						});
					}
				});
			})
			.catch(callback);
	};
	if (typeof cb === 'function') { fn(cb); }
	else { return Promisie.promisify(fn)(); }
};

/**
 * Runs full create seed suite and formats response
 * @param  {Object}   options Options object for create seed function
 * @param {Boolean} [options.useConfigurationFile] Default behavior is to infer settings from the mongoose instance set this property to true in order to pull settings from config file
 * @param {string} [options.configPath] If using configuration file this sets the path to that file
 * @param {Object} [options.mongooseConnection] Mongoose instance to be used in seed defaults to the current periodic instance
 * @param {string} [options.outputPath] Path for seed json file
 * @param {Boolean} [options.partition] Will create separate json seed file per collection if true
 * @param  {Function} [cb]      Optional callback function will return a Promise if cb arugment is not passed
 * @return {Object}           Returns a Promise if callback is not passed
 */
var exportSeed = function (options, cb) {
	let export_seed = function (callback) {
		options = Object.assign({}, exportOptions, options);
		options.outputPath = (typeof options.outputPath === 'string' &amp;&amp; options.outputPath.length) ? options.outputPath : path.join(__dirname, `../../../content/files/dbseed/${ moment().format('YYYY-MM-DD-hh:mm:ss') }/seed_data.json`);
		try {
			createSeed(options, (err, result) => {
				if (err) { callback(err); }
				else {
					if (options.partition) {
						callback(null, {
							export_result: result.map(r => {
								return {
									exportseedresult: r.data,
									exportSeedFilePath: r.path,
									numOfSeeds: r.records
								};
							}),
							options
						});
					}
					else {
						callback(null, {
							export_result: {
								exportseedresult: result.data,
								exportSeedFilePath: result.path,
								numOfSeeds: result.records
							},
							options
						});
					}
				}
			});
		}
		catch (e) {
			callback(e);
		}
	};
	if (typeof cb === 'function') { export_seed(cb); }
	else { return Promisie.promisify(export_seed)(); }
};

var initialize = function (resources) {
	logger = resources.logger;
	mongoose = resources.mongoose;
	appSettings = resources.settings;
	appenvironment = appSettings.application.environment;
	CoreController = resources.core.controller;
	CoreUtilities = resources.core.utilities;
	try {
		let export_configuration = require(path.join(__dirname, '../../../content/config/extensions/periodicjs.ext.dbseed/customseed.js'))(resources)[appenvironment];
		transformConfiguration = export_configuration.exportseed;
		exportDB = export_configuration.exportdb;
		exportOptions = export_configuration.exportoptions || {};
	}
	catch (e) {
		logger.warn('There is not a transform configuration file', e.stack);
	}
	return {
		writeSeedToDisk: writeToFile,
		createSeeds: createSeed,
		exportSeed
	};
};

module.exports = initialize;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cliDBSeedController.html">cliDBSeedController</a></li><li><a href="module-exportseed.html">exportseed</a></li><li><a href="periodicjs.ext.module_dbseed.html">dbseed</a></li></ul><h3>Classes</h3><ul><li><a href="WriteStreamSwitchboard.html">WriteStreamSwitchboard</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appendJSONToFile">appendJSONToFile</a></li><li><a href="global.html#checkdirexists">checkdirexists</a></li><li><a href="global.html#configureCreateQueue">configureCreateQueue</a></li><li><a href="global.html#configureQueryStreams">configureQueryStreams</a></li><li><a href="global.html#configureWriteQueue">configureWriteQueue</a></li><li><a href="global.html#createDataTransformStream">createDataTransformStream</a></li><li><a href="global.html#createSeed">createSeed</a></li><li><a href="global.html#deleteOldUpload">deleteOldUpload</a></li><li><a href="global.html#emptyAssets">emptyAssets</a></li><li><a href="global.html#emptyCategories">emptyCategories</a></li><li><a href="global.html#emptyCollections">emptyCollections</a></li><li><a href="global.html#emptyCompilations">emptyCompilations</a></li><li><a href="global.html#emptyContenttypes">emptyContenttypes</a></li><li><a href="global.html#emptyDatas">emptyDatas</a></li><li><a href="global.html#emptyDB">emptyDB</a></li><li><a href="global.html#emptyItems">emptyItems</a></li><li><a href="global.html#emptyTags">emptyTags</a></li><li><a href="global.html#emptyUsergroups">emptyUsergroups</a></li><li><a href="global.html#emptyUserprivileges">emptyUserprivileges</a></li><li><a href="global.html#emptyUserroles">emptyUserroles</a></li><li><a href="global.html#emptyUsers">emptyUsers</a></li><li><a href="global.html#ensureDBConnection">ensureDBConnection</a></li><li><a href="global.html#ensureExportDirectory">ensureExportDirectory</a></li><li><a href="global.html#export_download">export_download</a></li><li><a href="global.html#exportSeed">exportSeed</a></li><li><a href="global.html#getModelSettings">getModelSettings</a></li><li><a href="global.html#getModelSettingsFromFile">getModelSettingsFromFile</a></li><li><a href="global.html#getMongoQueryStream">getMongoQueryStream</a></li><li><a href="global.html#getPopulationSettings">getPopulationSettings</a></li><li><a href="global.html#handleArchivePartitionedFile">handleArchivePartitionedFile</a></li><li><a href="global.html#handleEndOfFile">handleEndOfFile</a></li><li><a href="global.html#handleParallelInsertQueue">handleParallelInsertQueue</a></li><li><a href="global.html#handleSeriesInsertQueue">handleSeriesInsertQueue</a></li><li><a href="global.html#import_customseed">import_customseed</a></li><li><a href="global.html#import_upload">import_upload</a></li><li><a href="global.html#import_upload_utils">import_upload_utils</a></li><li><a href="global.html#importSeed">importSeed</a></li><li><a href="global.html#index">index</a></li><li><a href="global.html#moveseed">moveseed</a></li><li><a href="global.html#readSeedFromFile">readSeedFromFile</a></li><li><a href="global.html#removeAssetFromDB">removeAssetFromDB</a></li><li><a href="global.html#reorderDataByImportOrder">reorderDataByImportOrder</a></li><li><a href="global.html#seeddb">seeddb</a></li><li><a href="global.html#sendExportDownload">sendExportDownload</a></li><li><a href="global.html#setupCompleteSeedFile">setupCompleteSeedFile</a></li><li><a href="global.html#setupInsertTask">setupInsertTask</a></li><li><a href="global.html#setupseeddata">setupseeddata</a></li><li><a href="global.html#transformDataForSeed">transformDataForSeed</a></li><li><a href="global.html#wipedb">wipedb</a></li><li><a href="global.html#writeToFile">writeToFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Dec 29 2016 11:29:06 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
