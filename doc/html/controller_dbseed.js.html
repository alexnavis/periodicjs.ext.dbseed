<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controller/dbseed.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controller/dbseed.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
const Promisie = require('promisie');
const fs = Promisie.promisifyAll(require('fs-extra'));
const path = require('path');
const moment = require('moment');
const defaultUploadDir = path.join(__dirname, '../../../content/files/dbseeds');
const defaultExportFileName = `dbemptybackup-${ moment().format('YYYY-MM-DD-hh:mm:ss') }.json`;
const archiver = require('archiver');

var logger;
var mongoose;
var appSettings;
var CoreController;
var CoreUtilities;
var export_db;
var import_db;
var dbopsModule;
var Asset;
var extJson;

var uploaded_seed_file = function (req, res) {
	res.send({
		result: 'success',
		data: req.controllerData
	});
};

var set_seed_upload_dir = function (req, res, next) {
	req.localuploadpath = defaultUploadDir;
	next();
};

/**
 * Sets headers and sends download to the client
 * @param {Object} options Options for sending the download
 * @param {Object} options.res Express response object used for sending download
 * @param {string} options.filePath Path to the file that is being downloaded
 */
var sendExportDownload = function (options) {
	let { res, filePath } = options;
	let exportFileName = path.basename(filePath);
	res.setHeader('Content-disposition', 'attachment; filename=' + exportFileName);
	res.setHeader('Content-type', (path.extname(exportFileName) === '.zip') ? 'application/zip' : 'application/json' );
	Promisie.promisify(res.download, res)(filePath, exportFileName)
		.then(() => fs.removeAsync(filePath))
		.then(() => logger.info('Successfully exported seed file'))
		.catch(logger.error);
};

/**
 * Handles the creation of the zip file when seed files are paritioned as part of an export
 * @param {Object} writeStream A writable stream which the zip data will be piped to
 * @param {Array} files An array of file paths for the seed files
 * @param {Function} [cb] Optional callback will return a Promise if not passed
 * @return {Object} Returns a Promise if cb argument is not passed
 */
var handleArchivePartitionedFile = function (writeStream, files, cb) {
	let handler = function (callback) {
		try {
			let archive = archiver('zip');
			writeStream.on('close', callback)
				.on('error', callback);
			archive.on('error', callback);
			archive.pipe(writeStream);
			for (let i = 0; i &lt; files.length; i++) {
				archive = archive.append(fs.createReadStream(files[i].exportSeedFilePath), { name: path.basename(files[i].exportSeedFilePath) });
			}
			archive.finalize();
		}
		catch (e) {
			callback(e);
		}
	};
	if (typeof cb === 'function') { handler(cb); }
	else { Promisie.promisify(handler)(); }
};

/**
 * Middleware used to call export seed function
 * @param {Object} req Express request object
 * @param {Object} req.body Contains configuration options for the seed export
 * @param {Boolean} req.body.partition If true separate seed files will be created for different schemas in db and a zip file will be downloaded
 * @param {string} req.body.outputPath Determines where the seed file will be created and its filename
 */
var export_download = function (req, res) {
	let downloadOptions = CoreUtilities.removeEmptyObjectValues(req.body);
	export_db.exportSeed(downloadOptions)
		.then(result => {
			if (downloadOptions.partition) {
				let zipPath = `${ path.join(path.dirname(downloadOptions.outputPath), path.basename(downloadOptions.outputPath, '.json')) }.zip`;
				let seedOutput = fs.createWriteStream(zipPath);
				handleArchivePartitionedFile(seedOutput, result, (err) => {
					if (err) {
						CoreController.handleDocumentQueryErrorResponse({
							err: err,
							res: res,
							req: req
						});
					}
					else { sendExportDownload({ res, filePath: zipPath }); }
				});
			}
			else { sendExportDownload({ res, filePath: result.exportSeedFilePath }); }
		}, e => {
			CoreController.handleDocumentQueryErrorResponse({
				err: e,
				res: res,
				req: req
			});
		});
};

/**
 *
 */
var import_upload_utils = function (req, res) {
	return {
		/**
		 * Utility function that sets some options for import utility functions
		 * @param {Object} options Configuration options for seed
		 * @param {string} options.seedpath Initial file path to the seed file
		 * @param {Boolean} options.useExistingSeed If true an additional originalseeduploadpath option will be added to the options object a set to a file path in the public directory
		 * @return {Object} Returns a Promise which resolves to the options passed to the function and appended options
		 */
		setupseeddata: function (options = {}) {
			try {
				let seedname = path.basename(options.seedpath);
				let newseedpath = path.join(__dirname, '../content/files/dbseeds', seedname);
				let originalseeduploadpath;
				if (!options.useExistingSeed) {
					originalseeduploadpath = path.join(__dirname, '../public', seedname);
				}
				return Promise.resolve(Object.assign({ seedname, newseedpath, originalseeduploadpath }, options));
			}
			catch (e) {
				return Promise.reject(e);
			}
		},
		/**
		 * Utility function that ensures that a file directory exists
		 * @param {Object} options Configuration options for seed
		 * @param {Boolean} options.useExistingSeed If true execution of the function is skipped
		 * @param {string} options.uploadseeddir Directory the seed file should be uploaded to
		 * @return {Object} Returns a Promise which resolves the options passed to the function
		 */
		checkdirexists: function (options = {}) {
			if (options.useExistingSeed) { return Promise.resolve(options); }
			else {
				return fs.ensureDirAsync(options.uploadseeddir)
					.then(() => options, e => Promise.reject(e));
			}
		},
		/**
		 * Utility function that moves a file from one location to another
		 * @param {options} options Configuration options for seed
		 * @param {Boolean} options.useExistingSeed If true execution of the function is skipped
		 * @param {string} options.originalseeduploadpath The path to the file to be moved
		 * @param {string} options.newseedpath The path to the new file location
		 * @return {Object} Returns a Promise which resolves the options passed to the function
		 */
		moveseed: function (options = {}) {
			if (options.useExistingSeed) { return Promise.resolve(options); }
			else {
				return fs.renameAsync(options.originalseeduploadpath, options.newseedpath)
					.then(() => options, e => Promise.reject(e));
			}
		},
		/**
		 * Utility function that removes an existing seed file from disc
		 * @param {Object} options Configuration options for seed
		 * @param {Boolean} options.useExistingSeed If true execution of the function is skipped
		 * @param {string} options.originalseeduploadpath Path to the file that should be removed
		 * @return {Object} Returns a Promise which resolves the options passed to the function
		 */
		deleteOldUpload: function (options = {}) {
			if (options.useExistingSeed) { return Promise.resolve(options); }
			else {
				return fs.removeAsync(options.originalseeduploadpath)
					.then(() => options, e => Promise.reject(e));
			}
		},
		/**
		 * Utility function will remove an asset from the db
		 * @param {Object} options Configuration options for seed
		 * @param {string} [options.assetid] If passed the asset will be removed from the db
		 * @return {Object} Returns a Promise which resolves to the options passed to the function
		 */
		removeAssetFromDB: function (options = {}) {
			if (options.assetid) {
				return Promisie.promisify(CoreController.deleteModel, CoreController)({
					model: Asset,
					deleteid: options.assetid,
					req,
					res
				})
					.then(() => options, e => Promise.reject(e));
			}
			else { return Promise.resolve(options); }
		},
		/**
		 * Utility function will wipe the db before seed or immediately resolve the options passed to it
		 * @param {Object} options Configuration options for seed
		 * @param {Boolean} [options.wipecheckbox] If true a seed file of the existing database will be created an then the db will be emptied
		 * @return {Object} Returns a Promise which resolves the options passed to the function
		 */
		wipedb: function (options = {}) {
			if (options.wipecheckbox) {
				return export_db.exportSeed({
					outputPath: path.join(__dirname, '../content/files/dbseeds', defaultExportFileName)
				})
					.then(result => Promisie.promisify(dbopsModule.emptyDB)({}))
					.then(() => options)
					.catch(e => Promise.reject(e));
			}
			else { return Promise.resolve(options); }
		},
		/**
		 * Runs the import command passed a file path to the seed file
		 * @param {Object} options Configuration options for seed
		 * @param {string} options.newseedpath File path or directory path to be used for seeding the db
		 * @return {Object} Returns a promise that resolves to import result
		 */
		seeddb: function (options = {}) {
			return import_db.importSeed({
				file: options.newseedpath
			});
		}
	};
};

/**
 * Uses JSON data submitted from UI to seed the database
 * @param {Object} req Express request object
 * @param {Object} req.body Contains configuration options for seed import
 * @param {Object} req.body.customseedjson Data to be used in seeding the database
 * @param {Object} res Express response object
 */
var import_customseed = function (req, res) {
	let uploadOptions = CoreUtilities.removeEmptyObjectValues(req.body);
	import_db.importSeed({ file: uploadOptions.customseedjson })
		.then(data => {
			CoreController.handleDocumentQueryRender({
				req,
				res,
				renderView: 'home/index',
				responseData: {
					pagedata: { title: 'New Item' },
					data: { result: 'success', data },
					user: req.user
				}
			});
		}, err => {
			CoreController.handleDocumentQueryErrorResponse({ err, req, res });
		});
};

/**
 * Imports seed data into database optionally drops original db if option passed
 * @param {Object} req Express request object
 * @param {Object} req.body Contains configuration options for seed import
 * @param {string} req.body.previousseed If true the seed file will be pulled from the public directory
 * @param {Object} res Express response object
 */
var import_upload = function (req, res) {
	let uploadOptions = CoreUtilities.removeEmptyObjectValues(req.body);
	let useExistingSeed = (uploadOptions.previousseed &amp;&amp; uploadOptions.previousseed === 'usepreviousseed') ? true : false;
	let import_utils = import_upload_utils(req, res);
	import_utils.setupseeddata(Object.assign({ useExistingSeed }, uploadOptions))
		.then(import_utils.checkdirexists)
		.then(import_utils.moveseed)
		.then(import_utils.deleteOldUpload)
		.then(import_utils.removeAssetFromDB)
		.then(import_utils.wipedb)
		.then(import_utils.seeddb)
		.then(() => {
			CoreController.handleDocumentQueryRender({
				res,
				req,
				renderView: 'home/index',
				responseData: {
					pagedata: { title: 'New Item' },
					data: { result: 'success' },
					user: req.user
				}
			});
		})
		.catch(err => CoreController.handleDocumentQueryErrorResponse({ err, req, res }));
};

/**
 * Loads the index view for dbseed extension
 * @param {Object} req Express request object
 * @param {Object} req.user Periodic user
 * @param {Object} res Express response object
 */
var index = function (req, res) {
	let getPluginViewDefaultTemplate = Promisie.promisify(CoreController.getPluginViewDefaultTemplate, CoreController).bind(CoreController, {
		viewname: 'p-admin/dbseed/index',
		themefileext: appSettings.templatefileextension,
		extname: 'periodicjs.ext.dbseed'
	});
	let readdirAsync = fs.readdirAsync.bind(fs, defaultUploadDir);
	Promise.all([getPluginViewDefaultTemplate(), readdirAsync()])
		.then(results => {
			CoreController.handleDocumentQueryRender({
				res: res,
				req: req,
				renderView: results[0],
				responseData: {
					pagedata: {
						title: 'DBSeed Import/Export',
						toplink: '&amp;raquo; DB Seed Import/Export',
						headerjs: ['/extensions/periodicjs.ext.dbseed/js/dbseed.min.js?v=' + extJson.version],
						extensions: CoreUtilities.getAdminMenu()
					},
					periodic: {
						version: appSettings.version
					},
					existingseeds: results[1],
					user: req.user
				}
			});
		}, e => {
			CoreController.handleDocumentQueryErrorResponse({
				err: e,
				res: res,
				req: req
			});
		});
};

var controller = function (resources) {
	logger = resources.logger;
	mongoose = resources.mongoose;
	appSettings = resources.settings;
	CoreController = resources.core.controller;
	CoreUtilities = resources.core.utilities;
	export_db = require(path.join(__dirname, '../lib/db_clone'))(resources);
	import_db = require(path.join(__dirname, '../lib/db_seed'))(resources);
	dbopsModule = require('./dbops')(resources);
	Asset = mongoose.model('Asset');
	extJson = (resources.app.locals &amp;&amp; resources.app.locals.dbseedExtJson) ? resources.app.locals.dbseedExtJson : { version: '1.0' };
	try {
		fs.ensureDirSync(defaultUploadDir);
	}
	catch (e) {
		logger.error(e);
	}
	return Object.assign({ index, export_download, import_upload, import_customseed, uploaded_seed_file, set_seed_upload_dir }, export_db, import_db);
};

module.exports = controller;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cliDBSeedController.html">cliDBSeedController</a></li><li><a href="module-exportseed.html">exportseed</a></li><li><a href="periodicjs.ext.module_dbseed.html">dbseed</a></li></ul><h3>Global</h3><ul><li><a href="global.html#appendJSONToFile">appendJSONToFile</a></li><li><a href="global.html#checkdirexists">checkdirexists</a></li><li><a href="global.html#configureCreateQueue">configureCreateQueue</a></li><li><a href="global.html#configureQueryStreams">configureQueryStreams</a></li><li><a href="global.html#configureWriteQueue">configureWriteQueue</a></li><li><a href="global.html#createSeed">createSeed</a></li><li><a href="global.html#deleteOldUpload">deleteOldUpload</a></li><li><a href="global.html#emptyAssets">emptyAssets</a></li><li><a href="global.html#emptyCategories">emptyCategories</a></li><li><a href="global.html#emptyCollections">emptyCollections</a></li><li><a href="global.html#emptyCompilations">emptyCompilations</a></li><li><a href="global.html#emptyContenttypes">emptyContenttypes</a></li><li><a href="global.html#emptyDatas">emptyDatas</a></li><li><a href="global.html#emptyDB">emptyDB</a></li><li><a href="global.html#emptyItems">emptyItems</a></li><li><a href="global.html#emptyTags">emptyTags</a></li><li><a href="global.html#emptyUsergroups">emptyUsergroups</a></li><li><a href="global.html#emptyUserprivileges">emptyUserprivileges</a></li><li><a href="global.html#emptyUserroles">emptyUserroles</a></li><li><a href="global.html#emptyUsers">emptyUsers</a></li><li><a href="global.html#export_download">export_download</a></li><li><a href="global.html#exportSeed">exportSeed</a></li><li><a href="global.html#getModelSettings">getModelSettings</a></li><li><a href="global.html#getModelSettingsFromFile">getModelSettingsFromFile</a></li><li><a href="global.html#getMongoQueryStream">getMongoQueryStream</a></li><li><a href="global.html#getPopulationSettings">getPopulationSettings</a></li><li><a href="global.html#handleArchivePartitionedFile">handleArchivePartitionedFile</a></li><li><a href="global.html#handleParallelInsertQueue">handleParallelInsertQueue</a></li><li><a href="global.html#handleSeriesInsertQueue">handleSeriesInsertQueue</a></li><li><a href="global.html#import_customseed">import_customseed</a></li><li><a href="global.html#import_upload">import_upload</a></li><li><a href="global.html#import_upload_utils">import_upload_utils</a></li><li><a href="global.html#importSeed">importSeed</a></li><li><a href="global.html#index">index</a></li><li><a href="global.html#moveseed">moveseed</a></li><li><a href="global.html#readSeedFromFile">readSeedFromFile</a></li><li><a href="global.html#removeAssetFromDB">removeAssetFromDB</a></li><li><a href="global.html#reorderDataByImportOrder">reorderDataByImportOrder</a></li><li><a href="global.html#seeddb">seeddb</a></li><li><a href="global.html#sendExportDownload">sendExportDownload</a></li><li><a href="global.html#setupCompleteSeedFile">setupCompleteSeedFile</a></li><li><a href="global.html#setupInsertTask">setupInsertTask</a></li><li><a href="global.html#setupseeddata">setupseeddata</a></li><li><a href="global.html#transformDataForSeed">transformDataForSeed</a></li><li><a href="global.html#wipedb">wipedb</a></li><li><a href="global.html#writeToFile">writeToFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue Sep 06 2016 09:53:15 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
